4.1.1)
[1] == [True] (remember that's syntactic sugar for (1:[] == True:[]) )

4.1.2)
instance (Ord a) => Ord [a] where
 [] <= _          = True
 xs <= []         = null xs
 (x:xs) <= (y:ys) = (x < y) || (x == y && xs <= ys)

4.1.3)
Using last' on any list of elements whose type is not an instance of Eq fails.
For example: last [sin] = sin; but last' [sin] = ⊥

4.1.4)
head (x:xs) = x         or alternatively,         head (Cons x xs) = x
head' (Snoc xs x) = if xs == Nil then x else head' xs

convert Nil         = []
convert (Snoc xs x) = convert xs ++ [x]

4.2.1)
[]:xs = xs                false, if xs = [[1]], then []:xs = [[],[1]]
[]:xs = [[], xs]          false, if xs = [], then []:xs =[[]]
xs:[] = xs                false, if xs = [1], [1]:[] = [[1]]
xs:[] = [xs]              true
xs:xs = [xs, xs]          false

4.2.2)
[[]] ++ xs   = xs         false
[[]] ++ xs   = [xs]       false
[[]] ++ xs   = [[], xs]   false
[[]] ++ [xs] = [[], xs]   true
[xs] ++ []   = [xs]       true, [] is the unit of (++)
[xs] ++ [xs] = [xs, xs]   true

4.2.3) xs ++ [] = xs
Proof by induction on xs
Case(⊥). For the left-hand side we reason
            ⊥ ++ []
    = {case exhaustion}
            ⊥
         Which equals the right-hand side, establishing the case.
Case([]). For the left-hand side we reason
            [] ++ []
    = {first equation for ++}
            []
         Which equals the right-hand side, establishing the case.
Case((x:xs)) For the left-hand side we reason
            (x:xs) ++ []
    = {second equation for ++}
            x:(xs ++ [])
    = {induction hypothesis}
            x:xs
         Which equals the right-hand side, establishing the case.
                                                                    ∎
4.2.4) concat (xss ++ yss) = concat xss ++ concat yss
Proof by induction on xss.
Case(⊥). For the left-hand side we reason
            concat(⊥ ++ yss)
    = {case exhaustion}
            concat ⊥
    = {case exhaustion}
            ⊥
         For the right-hand side
            concat ⊥ ++ concat yss
    = {case exhaustion}
            ⊥ ++ concat yss
    = {case exhaustion}
            ⊥
            Both sides are equal, establishing the case.
Case([]). For the left-hand side we reason
            concat([] ++ yss)
    = {first equation for ++}
            concat yss
         For the right-hand side
            concat [] ++ concat yss
    = {first equation for concat}
            [] ++ concat yss
    = {first equation for ++}
            concat yss
            Both sides are equal, establishing the case.
Case(x:xs) For the left-hand side we reason
            concat((xs:xss) ++ yss)
    = {second equation for ++}
            concat (xs:(xss ++ yss))
    = {second equation for concat}
            xs ++ concat (xss ++ yss))
    = {induction hypothesis}
            xs ++ concat xss ++ concat yss
    = {second equation for concat}
            concat (xs:xss) ++ concat yss
            Which equals the right-hand side, establishing the case.
                                                                    ∎

4.2.5) length (xs ++ ys) = length xs + length ys
Proof by induction on xs.
Case(⊥). For the left-hand side we reason
            length (⊥ ++ ys)
    = {case exhaustion}
            length ⊥
    = {case exhaustion}
            ⊥
         For the right-hand side
            length ⊥ + length ys
    = {case exhaustion}
            ⊥ + length ys
    = {(+) is strict}
            ⊥
            Both sides are equal, establishing the case.
Case([]). For the left-hand side we reason
            length ([] ++ ys)
    = {first equation for ++}
            length ys
          For the right-hand side
            length [] + length ys
    = {first equation for length}
            0 + length ys
    = {0 is the unit for (+)}
            length ys
Case(x:xs) For the left-hand side we reason
            length ((x:xs) ++ ys)
    = {second equation for ++}
            length (x:(xs ++ ys)
    = {second equation for length}
            1 + length (xs ++ ys)
    = {induction hypothesis}
            1 + length xs + length ys
           For the right-hand side
            length (x:xs) + length ys
    = {second equation for length}
            1 + length xs + length ys
            Which equals what we reached at on the left-hand side,
            establishing the case.
                                                                    ∎
4.2.6) reverse xs = ⊥ for all infinite lists
Proof by partial induction on xs
Case(⊥). For the left-hand side we reason
            reverse ⊥
    = {case exhaustion}
            ⊥
            Which equals the right-hand side, establishing the case.
Case(x:xs). For the left-hand side we reason
            reverse (x:xs)
    = {second equation for reverse}
            reverse xs ++ [x]
    = {induction hypothesis}
            ⊥ ++ [x]
    = {case exhaustion}
            ⊥
            Which equals the right-hand side, establishing the case.
                                                                    ∎

init xs = ⊥ for all infinite lists
Proof by partial induction on xs
Case(⊥). For the left-hand side we reason
            init ⊥
    = {definition of init}
            (reverse . tail . reverse) ⊥
    = {definition of (.), twice}
            reverse (tail (reverse ⊥))
    = {case exhaustion for reverse, tail, and reverse again}
            ⊥
            Which equals the right-hand side, establishing the case.
Case(x:xs). For the left-hand side we reason
            init (x:xs)
    = {definition of init}
            (reverse . tail . reverse) (x:xs)
    = {definition of (.), twice}
            reverse (tail (reverse (x:xs)))
    = {second equation for reverse}
            reverse (tail (reverse xs ++ [x])))
    = {reverse xs = ⊥ for all infinite lists, as previously proved}
            reverse (tail (⊥ ++ [x])))
    = {case exhaustion}
            reverse (tail ⊥ ))
    = {case exhaustion}
            reverse ⊥
    = {case exhaustion}
            ⊥
            Which equals the right-hand side, establishing the case.
                                                                    ∎

4.2.7) ?? TODO

4.2.8) rev2 [] = []
       rev2 (x:[]) = x:[]
       rev2 (x:y:[]) = y:x:[]
       rev2 (x:y:z:zs) = x:y:z:zs

4.2.9) Either one fo the two lists is the empty list [], or one has to be a
prefix of the other, and the longer one (if xs /= ys) has to be made of
complete repetitions of that prefix.

4.2.10) ⊥ (bottom)

4.2.11) Yes, it's pretty intuitive (TODO prove it!)

4.2.12) TODO

4.2.13) The easiest way is probably converting them to a Haskell list and
delegating the comparisons.
data Catlist a = Nil
               | Wrap a
               | Cat (Catlist a) (Catlist a)
               deriving Show

convert Nil = []
convert (Wrap a) = [a]
convert (Cat a b) = convert a ++ convert b

instance (Eq a) => Eq (Catlist a) where
  a == b = convert a == convert b
instance (Ord a) => Ord (Catlist a) where
  a <= b = convert a <= convert b

4.3.1)
map (map square) [[1,2], [3,4,5]] evaluates to [[1,4], [9,16,25]]

4.3.2)
map f ⊥  = ⊥    Since it has to apply f to every element of the list, even
                if f isn't strict, the computation doesn't end. One example
                is map (+1) [1..]
map ⊥ [] = []   The function is never applied, therefore never evaluated,
                giving the empty list, according to the first equation of map
                Example: map infinity [], where infinity x = x + infinity x

4.3.3) Remember that map :: (a -> b) -> [a] -> [b]
       Then:
       map map :: [a -> b] -> [[a] -> [b]]

4.3.4) map f (xs ++ ys) = map f xs ++ map f ys
Proof by induction on xs
Case(⊥). For the left-hand side we reason
            map f (⊥ ++ ys)
    = {case exhaustion}
            ⊥
         For the right-hand side
            map f ⊥ ++ map f ys
    = {case exhaustion}
            ⊥ ++ map f ys
    = {case exhaustion}
            ⊥
            Both sides are equal, establishing the case.
Case([]). For the left-hand side we reason
            map f ([] ++ ys)
    = {first equation for ++}
            map f ys
          For the right-hand side
            map f [] ++ map f ys
    = {first equation for map}
            [] ++ map f ys
    = {first equation for ++}
            map f ys
            Both sides are equal, establishing the case.
Case(x:xs). For the left-hand side we reason
            map f ((x:xs) ++ ys)
    = {second equation for ++}
            map f (x:(xs ++ ys))
    = {second equation for map}
            f x : map f (xs ++ ys))
    = {induction hypothesis}
            f x : (map f xs ++ map f ys)
            For the right-hand side
            map f (x:xs) ++ map f ys
    = {second equation for map}
            (f x : map f xs) ++ map f ys

Both (:) and (++) are infixr 5 operators, making both sides equal and
establishing the case.
                                                                    ∎

4.3.5) The naturality condition for inits is:
        map (map f) . inits = inits . map f
Following the explanations in the book and looking at the examples,
particularly the concat one which has a similar, albeit inverse, type, it can
be guessed.
Another way of reaching to the result is looking for the free theorem of the
[a] -> [[a]] type, which is exactly the naturality condition.

4.3.6)
filter p = concat . map box
  where box x = if p x
                   then [x]
                   else []

4.3.7)
dropWhile p [] = []
dropWhile p (x:xs) = if p x
                        then dropWhile p xs
                        else (x:xs)

takeWhile p [] = []
takeWhile p (x:xs) = if p x
                        then x:takeWhile' p xs
                        else []

4.3.8) Let's suppose that xs is a finite list of size m, and ys is another
       finite list of size n. Then we have

                          y1 ... yn y1 ... yn ... y1 ... ym
[x | x <- xs, y <- ys] = [x1,...,x1,x2,...,x2,...,xm,...,xm]

[x | y <- ys, x <- xs] = [x1,...,xm,x1,...,xm,...,x1,...,xm]
                          y1 ... y1 y2 ... y2 ... yn ... yn

It's easy to see that for both of them to be equal, x1 = x2 = ... = xm

4.3.9)
pairs n = [(x,y) | x <- [1..n], y <- [1..n]]

4.3.10)
quadruples n = [(a,b,c,d) | a <- [1..n], b <- [a..n], c <-[a..n],
d <- [c..n], a*a + b*b == c*c + d*d, a /= c && a /= d && a /= b]

4.3.11)
   [(x, y) | x <- [1..n], odd x, y <- [1..n]]
   concat [[(x,y) | y <- [1 .. n]] | x <- [1 .. n], odd x]]
   concat [map (\y -> (x,y)) [1 .. n] | x <- [1 .. n], odd x]
   concat (map (\x -> map (\y -> (x,y)) [1 .. n]) (filter odd [1 .. n]))

   [(x, y) | x <- [1..n], y <- [1..n], odd x]
   concat [[(x,y) | x <- [1 .. n]] | y <- [1 .. n], odd x]]
   concat [map (\x -> (x,y)) [1 .. n] | y <- [1 .. n], odd x]
   concat [map (\y -> map (\x -> (x,y)) (filter odd [1 .. n])) [1 .. n])

4.4.1) unzip :: [(a,b)] -> ([a], [b])
So unzip [⊥] doesn't typecheck.
unzip [(⊥, ⊥)] on the other hand, loops endlessly.

(TODO: solution taken from haskell's irc logs, try to fully understand it)
xys = (1,2):undefined:[]
zipp (unzip xys) = (1,2):undefined

4.4.2) TODO
4.4.3) TODO

4.5.1) filter p = foldr f []
         where f x xs = if p x then x:xs else xs

4.5.2) takeWhile = foldr f []
        where f x xs = if p x then x:xs else []
It's not possible to define dropWhile in terms of fold directly. It can be done
indirectly though, using the more general function:
       dropWhile' :: (a -> Bool) -> [a] -> ([a], [a])
       dropWhile' p xs = (dropWhile p xs, xs)
Eventually reaching to:
    dropWhile p = fst . foldr f ([],[])
        where f x (ys, xs) = (if p x then ys else x:xs, x:xs)
For the details, read Graham Hutton's paper "A tutorial on the universality and
expressiveness of fold", in particular section 4.

4.5.3) Only the foldl equation is true:
       foldl (-) x xs = (((x - x1) - x2) - ...) = x - sum xs
       foldr (-) x xs = x - (x1 - (x2 - (...)))
